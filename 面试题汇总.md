[toc]

### CSS面试题目

#### 页面优化

1 **加载阶段** 主要是关键资源文件的下载，减小要下载文件的体积和数量以及RTT的次数，文件大小和RTT匹配，一个RTT可以传输14kb大小文件

2 **交互阶段** 主要是提高合成帧的速度，可以通过

- 减小js函数的执行时间
- 避免重绘重排，尽量使用CSS动画
- 避免强制同步布局，所谓的强制同步布局就是将计算样式和计算布局放到当前任务中

#### svg jpeg png的区别

svg是可缩放矢量图形，无损压缩，支持透明度, 可以任意缩放大小且不损坏画质。

png支持透明度，文字，无损压缩

jpeg适用于大照片，摄影，有损压缩

[svg jpeg png的区别](https://zhuanlan.zhihu.com/p/53441916)

#### 输入url发生了什么

输入url， dns解析获得ip地址，然后建立tcp连接从服务器获得数据，得到html，提交文本给渲染进程(为什么输入url以后会停留在本页面一段时间的原因)->浏览器渲染html

#### 浏览器渲染html的过程

**html解析成dom树;**

**计算css**(先将css转换成浏览器能够理解的结构，再标准化em->px, 再计算); 

**布局(dom+css)得到布局树**(不包括隐藏节点), 布局树分层(只有具有层叠属性的元素才会单独一层，比如position z-index或者裁剪，裁剪是指容器元素不能展示全部的内容，自行增加滚动条);再进行布局计算。

 **图层绘制**：图层->(因为可能页面很大，用户只能看到一部分，所以先渲染能看到的部分，叫做视口)图块->(通过**栅格化**,可以借助gpu)位图;

**合成和显示**。

另外涉及到三个优化点，重排，重绘，合成。

重排是dom树结构变了，比如元素的高度，会重新布局

重绘元素的样式发生了变化，比如颜色，这样会跳过布局阶段。

合成，跳过布局和绘制阶段

![image-20210918144811664](/Users/luohanxiong/Library/Application Support/typora-user-images/image-20210918144811664.png)

#### css资源阻塞会影响dom树的构建？会影响页面的显示吗

不影响前者，css资源的请求会独立运行在网络进程中;会影响布局树的合成，布局树是dom+css, 会影响页面的显示，

### js面试题目

#### CommonJS和ES6 module的区别

1 前者是传递一个拷贝，后者是传递一个引用

2 前者是运行时加载，可以直接加载模块当成一个对象，然后调用对应对象暴露的属性和方法

后者是编译时加载，只能加载对应暴露的属性或者方法

#### 手写防抖节流 promise.all()

#### 简单请求，非简单请求和CORS

首先要理解CORS(跨域资源共享),CORS是一种机制，指的是服务器对跨域请求的处理，使得服务器可以标示除了自己以外的其他的域，让其他的域可以访问服务器上的资源。对于可能会对服务器产生副作用的请求，服务器需要一个option方法的预检请求来决定是否允许实际请求。若服务器允许，便可以发送实际请求。

简单请求就是不会出发CORS预检请求的请求。

涉及的http响应首部字段，比如

Access-Control-Allow-Origin:规定了允许跨域请求的域。

Access-Control-Allow-Method(Header)规定了允许的跨域请求的方法和携带的自定义头部。

**[CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#preflighted_requests)**

#### 事件队列和事件循环

一般调用一个方法的时候，如果不是异步方法将直接放入执行栈中执行，异步方法将放入事件队列中等待，当执行栈中所有方法执行完毕了，才去事件队列中将任务取出放入执行栈中执行，如此反复，称作事件循环

#### 闭包应用 节流和防抖

一段时间内事件连续触发

节流：让js代码每隔一段时间执行，间隔执行

防抖：最后一次触发事件以后执行,延迟执行

### http

#### 什么叫跨域，如何解决

#### 请求报文和响应报文

请求报文包括请求行(方法+url+http版本)，请求头(各种字段，比如accept，host)和请求数据(附带的参数)

响应报文包括响应行(版本+状态码+状态码描述)，响应头(字段，比如server，content-type)和响应数据

#### http缓存

分为强制缓存和对比缓存

前者在浏览器请求的时候，先去看缓存数据库是否命中，命中了则取，不命中再去请求服务器。通过Expires/Cache-Control字段来判断本地缓存是否失效。只有输入url或者书签才走强制缓存

后者不管怎样都会去请求服务器，发送两次请求，第一次请求本地缓存数据库获得本地缓存数据的标识，第二次请求附带标识向服务器验证判断本地缓存是否失效，304则可以使用本地缓存；200的话则保存响应的数据和标识；通过Etag/If-None-Match(**标识**）和Last-Modified/If-Modified-SInce字段（**时间**)判断本地缓存是否过期，前者优先级大于后者。

**[http缓存](https://segmentfault.com/a/1190000021716418)**

为什么会出现暂时性死区

```js
if (true) {
    
    temp = "kfdls";
    let temp; // 变量提升？ 程序编译的过程?
}
```



js中函数执行的过程中的参数传递过程

```js
var fruit = ["苹果","橙子","梨子"];
fruit.forEach(function(item,index, t){
    console.log("fruit[" + index + "] = " + item + t + s);
});
```

### 安全

#### XSS和CSRF

XSS是通过在页面中注入恶意脚本来获取用户的信息或者更改页面内容。

存储型XSS将恶意代码存储到数据库中，当用户请求的时候，从数据库中取出对应恶意代码，以html的形式返回给浏览器，浏览器解析执行正常代码和恶意代码

反射型XSS通过将恶意代码放在url中，服务端从url中取出恶意代码，放入html中并且返回给浏览器，恶意代码可以窃取用户的信息。

XSS主要危害是获得用户的相关信息或者改变页面

CSRF通过利用用户在网站的登陆状态，达到对网站的攻击。
