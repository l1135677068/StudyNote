[toc]

### 面试技巧

#### 自我介绍

面试官，您好，我叫罗汉雄，我现在是中国科学技术大学的一名研二学生，我的专业是软件工程，研究方向是大数据与人工智能。目前我正在美团外卖到家事业群基础平台组实习，日常工作中，我主要负责维护内部的一个敏捷协同平台，主要开发前端页面和后端接口；有时候还会承接少部分的外卖APP的需求。投递贵公司是想获得一个前端开发实习工程师的机会。以上就是我的基本情况。

#### 介绍项目技巧

1 先一句话概论，然后star原则细分

例如权限申请功能

1 这个项目用一句话概论来说就是将手动申请权限改成了半自动化的申请。

背景是这样的..

目标是...

我的任务是...

结果是...



### React

#### Fragment

是一个组件，作为一个不可见的外层，可以代替div，渲染的时候减少一层dom解析渲染

#### Diff算法流程

![image-20220126170546869](/Users/luohanxiong/Library/Application Support/typora-user-images/image-20220126170546869.png)

从patch方法开始，全是Diff算法的内容

应用：不建议用index作为li的key，否则如果在首部插入节点将会导致更新整个ul，而不是只更新新增的li

#### for循环中的key的作用是什么

主要是用来高效的更新节点的，因为diff算法在新旧节点首尾交叉对比均没有结果的时候，会根据新节点的key找在旧节点中查找，如果没有key则是遍历查找，有了key则是map映射(key -> index)，后者更快，所以更新更加迅速。

[参考](https://cloud.tencent.com/developer/article/1654364)

#### setState第二个参数的作用

当setState函数调用完成以后执行的回调函数

#### Ref

可以将ref挂载到dom节点或者组件上，可以通过ref的current属性获得dom节点或者组件实例。

#### 在哪个阶段发请求

类组件 componentDidMount()

hook useEffect()

#### createElement和cloneElement的区别

前者是创建并且返回元素，后者是以element元素为样板克隆并返回新的React元素。

[参考](https://zh-hans.reactjs.org/docs/react-api.html#cloneelement)

#### redux

用来统一管理state的，一般用在两级组件通信的时候。

#### 函数组件和类组件的区别

相同点是均呈现UI。

不同点是 1 设计思想不同（前者是函数思想，相同输入必定相同输出；后者是面向对象思想）2 语法不同

### CSS面试题目

#### 盒模型的两种模式

Box-sizing: border-box

怪异模式： 宽高包括了padding和border

标准模式： 宽高不包括padding和border

#### 页面优化

1 **加载阶段** 主要是关键资源文件的下载，减小要下载文件的体积和数量以及RTT的次数，文件大小和RTT匹配，一个RTT可以传输14kb大小文件

2 **交互阶段** 主要是提高合成帧的速度，可以通过

- 减小js函数的执行时间， 1 将一次执行的函数拆解成多个任务 2 使用web workers，可以理解成另一个线程，将不用操作dom且耗时的任务放入web workers中
- 避免重绘重排，尽量使用CSS动画
- 避免强制同步布局，所谓的强制同步布局就是将计算样式和计算布局放到当前任务中
- 避免频繁的垃圾回收

#### svg jpeg png的区别

svg是可缩放矢量图形，无损压缩，支持透明度, 可以任意缩放大小且不损坏画质。

png支持透明度，文字，无损压缩

jpeg适用于大照片，摄影，有损压缩

[svg jpeg png的区别](https://zhuanlan.zhihu.com/p/53441916)

#### 输入url发生了什么

输入url， dns解析获得ip地址，然后建立tcp连接从服务器获得数据，得到html，提交文本给渲染进程(为什么输入url以后会停留在本页面一段时间的原因)->浏览器渲染html

#### 浏览器渲染html的过程

**html解析成dom树;**

**计算css**(先将css转换成浏览器能够理解的结构，再标准化em->px, 再计算); 

**布局(dom+css)得到布局树**(不包括隐藏节点), 布局树分层(只有具有层叠属性的元素才会单独一层，比如position z-index或者裁剪，裁剪是指容器元素不能展示全部的内容，自行增加滚动条);再进行布局计算。

 **图层绘制**：图层->(因为可能页面很大，用户只能看到一部分，所以先渲染能看到的部分，叫做视口)图块->(通过**栅格化**,可以借助gpu)位图;

**合成和显示**。

另外涉及到三个优化点，重排，重绘，合成。

重排是dom树结构变了，比如元素的高度，会重新布局

重绘元素的样式发生了变化，比如颜色，这样会跳过布局阶段。

合成，跳过布局和绘制阶段

![image-20210918144811664](/Users/luohanxiong/Library/Application Support/typora-user-images/image-20210918144811664.png)

#### css资源阻塞会影响dom树的构建？会影响页面的显示吗

不影响前者，css资源的请求会独立运行在网络进程中;会影响布局树的合成，布局树是dom+css, 会影响页面的显示，

### js面试题目

#### ...运算符可以运用哪些类型

数组和字符串

#### typeof和instanceof的区别

#### 如何保证settimeout准时运行



#### promise和asyn和await区别



#### CommonJS和ES6 module的区别

1 前者是传递一个拷贝，后者是传递一个引用

2 前者是运行时加载，可以直接加载模块当成一个对象，然后调用对应对象暴露的属性和方法

后者是编译时加载，只能加载对应暴露的属性或者方法

3 转化。const d = require('a') 可以转化为 import * as d from 'a';

#### 手写防抖节流 promise.all()

#### 事件队列和事件循环

一般调用一个方法的时候，如果不是异步方法将直接放入执行栈中执行，异步方法将放入事件队列中等待，当执行栈中所有方法执行完毕了，才去事件队列中将任务取出放入执行栈中执行，如此反复，称作事件循环

#### 闭包应用 节流和防抖

一段时间内事件连续触发

节流：让js代码每隔一段时间执行，间隔执行

防抖：最后一次触发事件以后执行,延迟执行

#### 迭代器

#### 数组的方法

##### 调用函数的

foreach, map, filter, find, reduce

##### 操作数组的

push, pop, shift, unshift, splice, slice, reverse

#### JSON数据格式的优缺点

优点：简单易读，易于解析，体积小，支持多种语言

缺点：通用性不如XML

#### document ready和load的区别

前者是所有资源加载完毕以后执行的函数

后者是DOM树加载完成以后执行的函数

### http

#### 什么叫跨域，如何解决跨域请求

##### 简单请求，非简单请求和CORS 主流方案

首先要理解CORS(跨域资源共享),CORS是一种机制，指的是服务器对跨域请求的处理，使得服务器可以标示除了自己以外的其他的域，让其他的域可以访问服务器上的资源。对于可能会对服务器产生副作用的请求，服务器需要一个option方法的预检请求来决定是否允许实际请求。若服务器允许，便可以发送实际请求。

简单请求就是不会出发CORS预检请求的请求。

涉及的http响应首部字段，比如

Access-Control-Allow-Origin:规定了允许跨域请求的域。

Access-Control-Allow-Method(Header)规定了允许的跨域请求的方法和携带的自定义头部。

**[CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#preflighted_requests)**

##### 代理

后端代理请求，然后返回结果

##### Jsonp跨域

利用script标签跨域的特性, 前端与后端约定好一个函数，该函数用来执行跨域请求，前端请求，后端返回包含这个函数的js代码，前端执行该代码从而执行跨域请求。

#### 请求报文和响应报文

请求报文包括请求行(方法+url+http版本)，请求头(各种字段，比如accept，host)和请求数据(附带的参数)

响应报文包括响应行(版本+状态码+状态码描述)，响应头(字段，比如server，content-type)和响应数据

#### http缓存

分为强制缓存和协商缓存

前者在浏览器请求的时候，先去看缓存数据库是否命中，命中了则取，不命中再去请求服务器。通过Expires/Cache-Control字段来判断本地缓存是否失效。只有输入url或者书签才走强制缓存

**为什么不用expire了，因为返回的expire字段值是服务器端时间+最大存活时间，如果客户端更改了本地时间，并且比服务端时间快，则会导致明明没有过期，可以使用缓存但还是去向服务器请求。**

后者不管怎样都会去请求服务器，发送两次请求，第一次请求本地缓存数据库获得本地缓存数据的标识，第二次请求附带标识向服务器验证判断本地缓存是否失效，304则可以使用本地缓存；200的话则保存响应的数据和标识；通过If-None-Match(**标识**）/Etag和If-Modified-SInce/Last-Modified字段（**时间**)判断本地缓存是否过期，前者优先级大于后者。

**[http缓存](https://segmentfault.com/a/1190000021716418)**

#### http状态码

301 302, 404, 304, 502,

#### https

为什么https通信使用对称加密(三个随机数)，而使用非对称加密验证证书建立连接

原因：1 非对称加密解密速度较慢 2 使用非对称加密的话，只有服务端有私钥，只能实现单向的加密解密

如果不验证证书怎么办？

导致a-c通信变成a-b-c通信，b是中间人，知道了所有信息。

[https加密的过程](https://zhuanlan.zhihu.com/p/96494976)

#### 对称加密和非对称加密

对称加密是双方使用同一个密钥

非对称加密是一个是用公钥，一个使用私钥，一般是服务端将公钥发送给客户端，客户端使用公钥加密信息，服务端使用私钥解密信息。

#### cookie和session

什么时候用cookie 什么时候用session

[cookie和session的区别](https://wuch886.gitbooks.io/front-end-handbook/content/session-cookiehe-token-san-zhe-de-guan-xi-he-qu-bie.html)

##### 定义

cookie就是服务端发送给浏览器并且保存到本地的一小块数据。

session是客户端和服务端会话的过程，session对象存储着会话的配置信息。

##### 区别

* 存储位置
* 存储大小 cookie最多为4KB
* 存储时间

##### 关联

cookie和session通过sessionId来关联，sessionId存储在cookie中;附带cookie向服务器发起请求，服务器从cookie中取出sessionId从而得到session对象，得到会话的配置信息;

如果禁止cookie的话，可以采用token或者直接吧sessionID放入url中

token就是服务端为特定客户端生成的并且响应给客户端的字符串，下次客户端请求时附带这个token即可。

##### 第一方cookie和第三方cookie

前者是你访问的网站创建的，用来保存回话信息的

后者是和当前访问网站不同域名创建的，可以跟踪你在当前网站的行为，从而进行推荐广告等行为。

##### HttpOnly属性

设置为true以后则不能通过document.cookie访问

##### session的缺点

1 session会话信息保存在服务端，当请求增多的时候，服务端压力很大

2 服务器为集群的时候，处理用户请求的服务器并不保存着该用户的session信息，解决方法：统一一个服务器保存session信息

### 安全

#### XSS和CSRF

[xss和csrf的概念和防护](https://tech.meituan.com/2018/09/27/fe-security.html)

##### XSS

XSS是通过在页面中注入恶意代码来获取用户的cookie信息或者更改页面内容。

* 存储型XSS将恶意代码存储在**数据库**中，当用户请求的时候，从数据库中取出对应恶意代码，拼接在HTML中返回给浏览器，浏览器解析执行正常代码和恶意代码。
* 反射型XSS通过将恶意代码放在**URL**中，**服务端从url中取出恶意代码**，拼接在HTML中并且返回给浏览器执行。
* DOM型XSS **前端js代码**从恶意的URL中取出恶意代码并且执行。
* 总结，第三个和前两者最大的区别是，第三个是前端js漏洞，前两个是服务端漏洞

##### XSS解决方法

XSS攻击需要两步

> ​	1 攻击者提交代码
>
> ​	2 浏览器执行恶意代码

通常无法从提交代码解决

从避免浏览器执行恶意代码解决

* 对HTML进行充分的转义, 前端如何转义

* 纯前端渲染，静态HTML页面，通过AJAX技术获取业务数据

* 预防DOM型XSS， 在使用一些API的时候注意，尤其是插入位置为html属性，链接的时候

* 其他措施 CSP，限制输入内容长度

  

##### CSRF

CSRF攻击者利用用户在被攻击网站的登录状态，冒充用户，在被攻击网站上执行自己定义的操作。

主要是a和form标签来跨域攻击。

##### CSRF解决方法

* 同源验证，Origin和Referer字段

* CSRF Token,请求的时候附带token，来区别是正常请求还是攻击请求。Token存放在服务器的session中

* 双重cookie，用户请求的时候附带cookie信息作为参数

  

##### XSS和CSRF本质区别：

XSS可以获取用户的cookie，CSRF不能获取用户的cookie

### 浏览器

#### v8垃圾回收机制

代际假说

> 1 很多对象一经分配内存，很快就变得不可访问。
>
> 2 不死的对象，会活得更久。

回收策略

> 1 标记活动对象和非活动对象
>
> 2 回收非活动对象
>
> 3 清理内存碎片

新生区: 标记复制

老生区: 标记清除，因为对象大，复制效率较低。

#### 排查内存泄露的工具

### 操作系统

#### 进程和线程的区别

#### 进程通信和线程通信的区别

主要区别是线程通信主要是对共享资源访问的限制，进程通信是进程间资源的交互包括(管道，消息队列，共享内存，信号量，信号，套接字)

### Node.js相关面试题

#### devDependency dependency peerDependency

前者是开发依赖，中间是线上依赖，最后是特定某个包的版本。

中间写入前面不会产生很大影响。

### hr面试一般会问的问题





