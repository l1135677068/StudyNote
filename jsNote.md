[toc]

### js的基础知识

#### 数据类型

##### 基本数据类型 Number String Boolean Undefined Null

​	String可以用""或者''定义，c++中""定义字符串''定义字符

​	字符串中的常用方法: concat()拼接字符串 substring() indexof() 返回子串的位置 match() 匹配正则表达式

##### Object(Array, Function)

###### 数组的常用方法

​	添加元素 push, unshift,

​	删除元素 pop, shift

​	每个元素调用回调函数 map,  find

​	在原数组上生成新数组 concat, join,

​	特殊方法splice, slice, sort

​	不会改变数组的方法 map slice concat filter

​	改变数组的方法push pop shift unshift splice sort reverse foreach

### 基础知识

#### new的过程

```js
function CreateObj(){
  this.name = "极客时间"
}
var myObj = new CreateObj()
```

可以这样理解

```js
var tempObj = {}
CreateObj.call(tempObj)
return tempObj
```



#### 执行上下文

**编译阶段的时候会生成可执行代码和执行上下文，执行上下文中有变量环境和词法环境 以及this和outer，变量环境存储变量提升的变量和函数声明的变量，在变量提升的时候，这些变量为undefined，函数有函数名属性和值，值指向堆中函数的位置; 只有let和const变量放在词法环境中; outer用于形成作用域链, 在哪声明, outer指向哪; this(函数嵌套的时候，内部函数的this指向不会指向外部函数，而是指向window)**

#### 变量提升

编译阶段将函数和变量的声明提到代码的开头,且变量提升仅针对var

js代码->词法分析->预编译(得到执行上下文和可执行代码)->执行(可执行代码)

#### var和let的异同

let关键字不允许在相同作用域，重复声明同一变量

#### 暂时性死区

本质就是只要一进入当前作用域，变量就已经存在，在执行到声明该变量的那一行代码前，均不可使用该变量

#### 错误处理

Try{可能发生错误的地方,可以通过throw主动抛出错误}catch(){当前面代码产生错误的时候，执行这部分代码}finally{不管前面代码是否出错，这部分代码都要执行}

#### 原型链和原型对象

js在创建每个函数的时候都会默认创建一个该函数的原型对象，prototype属性存储着指向原型对象的指针，而原型对象存储着实例共享的属性或者方法，可以被继承。一般来说，实例拥有指向原型对象的指针，原型对象拥有指向构造函数的指针。

原型链就是实例所指向的原型对象为另一个类型的实例，这样可以递归下去。

#### JS继承

6种方式: 原型链继承(**使用prototype指向另一个实例**)，原型式继承(object.create)，寄生式继承，寄生组合继承(object + 构造函数)，组合继承(**原型链+构造函数)**，借用构造函数继承(**子函数中调用父类的构造函数.call()**)。

#### apply() call() bind()方法

用来设置函数执行上下文时的this指向

前两者主要是用来改变this指向的，前者apply参数打包成一个数组，后者按顺序传递参数

bind函数也是改变this指向，bind(object, 参数..) a.bind(b, c,d,e), a(f),例如这个例子，a绑定了b，那么a调用b的方法的时候，参数顺序为cdef，按照这个参数顺序调用b的原函数。

#### import和require的区别

​	require是动态导入，只有运行到其所在的那一行才会导入，并且会缓存下来。

#### 具有iterator属性的可迭代的数据结构

Array, Map, String, Set, TypedArray.函数的arguments对象,NodeList对象。

#### 作用域和作用域链 词法作用域和词法环境

作用域就是变量可见可访问的区域

作用域链就是作用域之间嵌套形成的,由词法作用域决定，简而言之，函数在哪声明的，其outer指向哪。

词法作用域是在编译确定的函数作用域

词法环境是js引擎存储变量和对象引用的地方，只有let和const会创建词法环境。通过这个保证了变量提升和块级作用域。

#### event loop

js是单线程的，代码执行的时候分为执行栈和事件队列；非异步函数放入执行栈，异步函数放入事件队列中，当执行栈为空以后才去执行事件队列中的函数。为了区分优先级不同的事件，又引入了宏任务和微任务，所以执行顺序是执行栈=>微任务（promise.then)=>宏任务（settimeout==）

### ES6和ES5的区别

#### ES6引入了let和const关键字

1 ES6允许在块级作用域内声明函数类似于let，且在支持ES6的浏览器中可以有自己的规则(块级作用域内声明函数类似var，会被提升到全局作用域或函数头部作用域) **由于不同浏览器的行为方式不同，因此避免在块级作用域内声明函数，如果必须建议使用函数表达式** 

```javascript
{let a = "js";
  //函数表达式
	let f = function() {
	return a;
	}
}
```



2 const的本质是**变量所指向的内存地址中保存的那个值不可变**

3 箭头函数

​	没有绑定this，没有arguments对象,没有function关键字，通常(paras) => {expression}, 不可以当作构造函数

4 变量的解构赋值的用处

​	1 交换变量的值 2 从函数返回多个值 3 函数参数的定义 4 提取json数据 5 获取输入模块的指定方法

5 函数的扩展

​	1 允许为函数的参数设置默认值，是默认声明的, 并且是尾参数有默认值才能省略

​	2 与解构赋值默认值结合使用?

​	3 函数的length属性返回没有指定默认值的参数的个数

6 尾调用

​	函数的最后一步是调用另一个函数,这样不会保存外部函数的调用帧, 尾递归优化只在严格模式下生效

​	用处:斐波那契可以计算很大的数

### js的DOM和BOM

#### BOM对象

​	1 window, alert(), confirm(),

​	2 navigator 一些方法和属性

​	3 location 即是window的属性也是document的属性，保存当前文档的信息(包括url，host==)

​	4 history 保存用户上网的历史记录

#### DOM对象

​	1通过类名和标签名得到的是一个数组

​	2 事件 冒泡：事件从具体的元素接受，逐级向上传递到不具体的节点；事件捕获和冒泡相反，从不具体的节点传递到具体的元素。

​	3 添加事件的三种方法，html中元素添加onclick属性，js中实现方法; js中得到具体的元素对象，设置onclick属性(DOM0级)或者调用addEventListener()方法(DOM2级)。

​	4 attachEvent()和DOM0的区别主要是作用域不同，前者作用域是全局

​	5 跨浏览器的事件处理程序 因为不同浏览器支持不同的添加事件方法，需要先判断是否存在，在进行添加。

​	6 事件对象(event) currenttarget和target的区别，前者是处理事件的元素，后者是触发事件的元素。

​	7 ie中event对象是window的属性

​	8 事件流和事件代理

​	事件流分为三个阶段，捕获阶段，目标阶段和冒泡阶段。

​	事件代理就是在事件溜冒泡阶段，通过对父元素事件监听达到对子元素事件监听的效果。常见手段是ul和li	

#### 事件类型

​	1 点击事件 2 鼠标事件 3 滚轮事件 4 文本事件 5 键盘事件 6合成事件(输入字符)

#### 内存和性能

​	1 使用事件委托来避免重复的点击事件

​	2 移除事件：移除元素或者手动移除；在浏览器卸载页面之前移除页面中的所有事件处理程序

#### Promise对象

​	1 新建Promise是立刻执行的,只有三种状态执行中，成功和失败

​	2 Promise的参数是一个函数，该函数有两个默认参数resolve和reject，Promise对象可以调用then(fun1, fun2),参数是两个参数，分别对应前面函数执行成功(失败）时候调用的函数， 当执行失败的时候，执行catch(fun3)的函数，finally代表最终都要执行的函数。通过调用resolve()和reject()来改变promise对象的状态

​	3 带有async关键字的函数，会默认返回promise对象，await函数只在async函数中有效

### AJAX

1 创建XMLHttpRequest对象，open建立请求，send()发送请求